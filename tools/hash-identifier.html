<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Hash Identifier</title>
  <style>
    :root {
      --primary: #4caf50;
      --primary-hover: #32cd32;
      --card-bg: rgba(30, 30, 30, 0.95);
      --text-color: #f0f0f0;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, sans-serif;
      background: #000;
      color: var(--text-color);
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      padding: 40px 20px;
    }

    .container {
      background: var(--card-bg);
      backdrop-filter: blur(8px);
      padding: 25px;
      border-radius: 16px;
      max-width: 650px;
      width: 100%;
      box-shadow: 0 10px 30px rgba(0, 255, 0, 0.1);
      display: flex;
      flex-direction: column;
      gap: 16px;
      position: relative;
    }

    h1 {
      text-align: center;
      margin: 0 0 10px 0;
      font-size: 24px;
    }

    .input-group {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .input-group label {
      font-size: 0.9rem;
      font-weight: 500;
    }

    input, select {
      width: 100%;
      padding: 10px;
      border-radius: 8px;
      border: none;
      background: #2a2a2a;
      color: var(--text-color);
      font-size: 1rem;
    }

    textarea {
      width: 100%;
      padding: 10px;
      border-radius: 8px;
      border: none;
      background: #2a2a2a;
      color: var(--text-color);
      font-size: 1rem;
      resize: vertical;
      min-height: 100px;
    }

    button {
      padding: 12px;
      background: linear-gradient(90deg, var(--primary), var(--primary-hover));
      color: #fff;
      border: none;
      border-radius: 8px;
      font-size: 1rem;
      cursor: pointer;
      transition: background 0.3s, box-shadow 0.3s;
      font-weight: bold;
    }

    button:hover {
      background: linear-gradient(90deg, var(--primary-hover), var(--primary));
      box-shadow: 0 0 10px var(--primary-hover);
    }

    button:focus {
      outline: 2px solid #fff;
      outline-offset: 2px;
    }

    .btn-outline-primary {
      background: none;
      border: 2px solid var(--primary);
      color: var(--primary);
    }

    .btn-outline-primary:hover {
      background: linear-gradient(90deg, var(--primary), var(--primary-hover));
      color: var(--text-color);
      box-shadow: 0 0 10px var(--primary-hover);
    }

    .result {
      background: #2a2a2a;
      padding: 16px;
      border-radius: 8px;
      margin-top: 16px;
      font-size: 1rem;
    }

    .result ul {
      list-style: none;
      padding: 0;
    }

    .result li {
      padding: 8px 0;
      display: flex;
      justify-content: space-between;
    }

    .toast {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: var(--primary);
      color: #000;
      padding: 6px 12px;
      border-radius: 8px;
      font-weight: bold;
      opacity: 0;
      transition: opacity 0.3s;
      z-index: 10;
    }

    .toast.show {
      opacity: 1;
    }

    .error-text {
      color: #f44336;
      font-size: 0.85rem;
      margin-top: 4px;
      display: none;
    }

    .generated-msg {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      background: var(--primary);
      color: #000;
      padding: 6px 12px;
      border-radius: 8px;
      font-weight: bold;
      z-index: 10;
    }

    @media (max-width: 500px) {
      .container {
        padding: 16px;
      }

      h1 {
        font-size: 20px;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Hash Identifier</h1>

    <div class="input-group">
      <label for="hashInput">Hash</label>
      <input type="text" id="hashInput" list="hashHistory" placeholder="Enter hash to identify" required aria-label="Enter hash to identify">
      <datalist id="hashHistory"></datalist>
      <small class="error-text">Enter a valid hash</small>
    </div>

    <div class="input-group">
      <label for="saltInput">Salt (optional)</label>
      <input type="text" id="saltInput" placeholder="Enter salt if known" aria-label="Enter salt (optional)">
      <small class="error-text">Invalid salt format</small>
    </div>

    <div class="flex-row">
      <button id="identify" aria-label="Identify Hash">Identify Hash</button>
      <button id="copy" class="btn-outline-primary" aria-label="Copy Result">Copy Result</button>
    </div>

    <div id="result" class="result">
      <p>Possible hash types will appear here after identification.</p>
    </div>
  </div>

  <div id="toast" class="toast"></div>

  <script>
    const elements = {
      identify: document.getElementById('identify'),
      copy: document.getElementById('copy'),
      hashInput: document.getElementById('hashInput'),
      saltInput: document.getElementById('saltInput'),
      result: document.getElementById('result'),
      toast: document.getElementById('toast'),
      hashHistory: document.getElementById('hashHistory')
    };

    let hashHistory = JSON.parse(localStorage.getItem('hashHistory')) || [];

    function saveHistory() {
      localStorage.setItem('hashHistory', JSON.stringify(hashHistory));
    }

    function loadHistory() {
      elements.hashHistory.innerHTML = '';
      hashHistory.forEach(entry => {
        const option = document.createElement('option');
        option.value = entry.hash;
        option.textContent = entry.salt ? `${entry.hash} (Salt: ${entry.salt})` : entry.hash;
        elements.hashHistory.appendChild(option);
      });
    }

    function addToHistory(hash, salt) {
      const entry = { hash, salt: salt || '' };
      if (!hashHistory.some(e => e.hash === hash && e.salt === salt)) {
        hashHistory.unshift(entry);
        if (hashHistory.length > 10) {
          hashHistory.pop();
        }
        saveHistory();
        loadHistory();
      }
    }

    function showToast(message) {
      elements.toast.textContent = message;
      elements.toast.classList.add('show');
      setTimeout(() => elements.toast.classList.remove('show'), 3000);
    }

    function identifyHash(hash, salt) {
      const trimmedHash = hash.trim();
      const trimmedSalt = salt ? salt.trim() : '';
      
      if (!trimmedHash) {
        elements.hashInput.nextElementSibling.style.display = 'block';
        showToast('Hash is required');
        return { types: [], confidence: 0 };
      }

      // Basic salt validation: allow alphanumeric and common special chars, no length restriction
      if (trimmedSalt && !/^[A-Za-z0-9+/=.-]*$/.test(trimmedSalt)) {
        elements.saltInput.nextElementSibling.style.display = 'block';
        showToast('Invalid salt format');
        return { types: [], confidence: 0 };
      }

      const hashTypes = [
        // Common hash types (higher weight)
        { name: 'MD5', length: 32, regex: /^[a-f0-9]{32}$/i, salted: false, weight: 0.9 },
        { name: 'SHA-1', length: 40, regex: /^[a-f0-9]{40}$/i, salted: false, weight: 0.85 },
        { name: 'SHA-256', length: 64, regex: /^[a-f0-9]{64}$/i, salted: false, weight: 0.9 },
        { name: 'SHA-512', length: 128, regex: /^[a-f0-9]{128}$/i, salted: false, weight: 0.85 },
        { name: 'bcrypt', length: 60, regex: /^\$2[ayb]\$[0-9]{2}\$[A-Za-z0-9./]{53}$/, salted: true, weight: 0.95 },
        { name: 'Argon2i', length: 0, regex: /^\$argon2i\$v=\d+\$m=\d+,t=\d+,p=\d+\$[A-Za-z0-9+/=]{22}\$[A-Za-z0-9+/=]{43}$/, salted: true, weight: 0.9 },
        { name: 'Argon2id', length: 0, regex: /^\$argon2id\$v=\d+\$m=\d+,t=\d+,p=\d+\$[A-Za-z0-9+/=]{22}\$[A-Za-z0-9+/=]{43}$/, salted: true, weight: 0.9 },
        { name: 'md5crypt (Unix)', length: 0, regex: /^\$1\$[A-Za-z0-9./]{1,8}\$[A-Za-z0-9./]{22}$/, salted: true, weight: 0.85 },
        { name: 'sha512crypt (Unix)', length: 0, regex: /^\$6\$[A-Za-z0-9./]{1,16}\$[A-Za-z0-9./]{86}$/, salted: true, weight: 0.85 },
        { name: 'Django (SHA-256)', length: 0, regex: /^sha256\$[A-Za-z0-9]+\$[a-f0-9]{64}$/i, salted: true, weight: 0.8 },
        // Less common hash types (lower weight)
        { name: 'SHA-224', length: 56, regex: /^[a-f0-9]{56}$/i, salted: false, weight: 0.7 },
        { name: 'SHA-384', length: 96, regex: /^[a-f0-9]{96}$/i, salted: false, weight: 0.7 },
        { name: 'SHA3-256', length: 64, regex: /^[a-f0-9]{64}$/i, salted: false, weight: 0.65 },
        { name: 'SHA3-512', length: 128, regex: /^[a-f0-9]{128}$/i, salted: false, weight: 0.65 },
        { name: 'NTLM', length: 32, regex: /^[a-f0-9]{32}$/i, salted: false, weight: 0.75 },
        { name: 'MySQL 4.1+', length: 40, regex: /^[a-f0-9]{40}$/i, salted: false, weight: 0.7 },
        { name: 'Salted SHA-256', length: 0, regex: /^[a-f0-9]{64}:.+$/i, salted: true, weight: 0.8 },
        { name: 'Salted SHA-512', length: 0, regex: /^[a-f0-9]{128}:.+$/i, salted: true, weight: 0.8 },
        // Rare hash types (lowest weight)
        { name: 'RIPEMD-160', length: 40, regex: /^[a-f0-9]{40}$/i, salted: false, weight: 0.5 },
        { name: 'Whirlpool', length: 128, regex: /^[a-f0-9]{128}$/i, salted: false, weight: 0.4 },
        { name: 'HAVAL-256', length: 64, regex: /^[a-f0-9]{64}$/i, salted: false, weight: 0.3 },
        { name: 'BLAKE2b-512', length: 128, regex: /^[a-f0-9]{128}$/i, salted: false, weight: 0.3 },
        { name: 'BLAKE3-256', length: 64, regex: /^[a-f0-9]{64}$/i, salted: false, weight: 0.3 }
      ];

      let possibleTypes = hashTypes.filter(type => {
        // If salt is provided, only consider salted hash types or formats with embedded salt
        if (trimmedSalt && !type.salted) return false;
        // If no salt is provided, only consider unsalted hash types or formats with embedded salt
        if (!trimmedSalt && type.salted && !type.regex.source.includes('\\$') && !type.regex.source.includes(':')) return false;
        // Check length and regex
        const lengthMatch = type.length === 0 || type.length === trimmedHash.length;
        const regexMatch = type.regex.test(trimmedHash);
        return lengthMatch && regexMatch;
      });

      // Additional contextual checks to improve accuracy
      possibleTypes = possibleTypes.filter(type => {
        if (type.name === 'bcrypt') {
          // Ensure bcrypt has valid cost factor (04-31)
          const cost = parseInt(trimmedHash.split('$')[2], 10);
          return cost >= 4 && cost <= 31;
        }
        if (type.name.startsWith('Argon2')) {
          // Ensure Argon2 has valid parameters
          const parts = trimmedHash.split('$');
          if (parts.length !== 6) return false;
          const params = parts[3].split(',');
          return params.length === 3 && params.every(p => p.includes('=') && !isNaN(parseInt(p.split('=')[1])));
        }
        if (type.name.includes('Unix')) {
          // Ensure Unix crypt formats have valid salt lengths
          const salt = trimmedHash.split('$')[2];
          return salt.length >= 1 && salt.length <= (type.name.includes('sha512') ? 16 : 8);
        }
        return true;
      });

      // Calculate percentage probabilities
      const totalWeight = possibleTypes.reduce((sum, type) => sum + type.weight, 0);
      possibleTypes = possibleTypes.map(type => ({
        name: type.name,
        probability: totalWeight > 0 ? (type.weight / totalWeight) * 100 : 0
      }));

      // Sort by probability (descending)
      possibleTypes.sort((a, b) => b.probability - a.probability);

      // Determine overall confidence
      const confidence = possibleTypes.length === 1 ? 0.95 : possibleTypes.length <= 3 ? 0.7 : 0.5;

      if (possibleTypes.length === 0) {
        elements.hashInput.nextElementSibling.style.display = 'block';
        showToast('No matching hash types found');
        return { types: [], confidence: 0 };
      }

      elements.hashInput.nextElementSibling.style.display = 'none';
      elements.saltInput.nextElementSibling.style.display = 'none';
      return {
        types: possibleTypes,
        confidence: confidence
      };
    }

    function displayResult(hashResult) {
      const resultDiv = elements.result;
      resultDiv.innerHTML = '';

      if (hashResult.types.length === 0) {
        resultDiv.innerHTML = '<p>No matching hash types found.</p>';
        return;
      }

      const ul = document.createElement('ul');
      hashResult.types.forEach(type => {
        const li = document.createElement('li');
        li.innerHTML = `<span>${type.name}</span><span>${type.probability.toFixed(1)}%</span>`;
        ul.appendChild(li);
      });
      resultDiv.appendChild(ul);

      const msg = document.createElement('div');
      msg.className = 'generated-msg';
      msg.textContent = `Identified! (${(hashResult.confidence * 100).toFixed(0)}% confidence)`;
      document.body.appendChild(msg);
      setTimeout(() => msg.remove(), 1000);
    }

    async function copyResult() {
      const resultText = Array.from(elements.result.querySelectorAll('li'))
        .map(li => li.textContent)
        .join('\n');
      if (!resultText || elements.result.textContent === 'Possible hash types will appear here after identification.') {
        showToast('Identify a hash first');
        return;
      }

      try {
        await navigator.clipboard.writeText(resultText);
        const msg = document.createElement('div');
        msg.className = 'generated-msg';
        msg.textContent = 'Copied!';
        document.body.appendChild(msg);
        setTimeout(() => msg.remove(), 1000);
      } catch (error) {
        showToast('Failed to copy result: ' + error.message);
      }
    }

    function identify() {
      const hash = elements.hashInput.value;
      const salt = elements.saltInput.value;
      elements.identify.disabled = true;
      elements.identify.textContent = 'Identifying...';

      try {
        const hashResult = identifyHash(hash, salt);
        displayResult(hashResult);
        if (hashResult.types.length > 0) {
          addToHistory(hash, salt);
        }
      } catch (error) {
        showToast('Error identifying hash: ' + error.message);
      } finally {
        elements.identify.disabled = false;
        elements.identify.textContent = 'Identify Hash';
      }
    }

    loadHistory();

    elements.identify.addEventListener('click', identify);
    elements.copy.addEventListener('click', copyResult);
    elements.hashInput.addEventListener('keypress', e => {
      if (e.key === 'Enter') identify();
    });
    elements.saltInput.addEventListener('keypress', e => {
      if (e.key === 'Enter') identify();
    });
  </script>
</body>
</html>
